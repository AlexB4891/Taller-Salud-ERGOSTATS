---
title: "Taller Salud ERGOSTATS"
author: "Pablo Sarango"
format: html
editor: visual
execute:
  eval: false
---

# Sección 1: Crear las zonas de influencia o captación

::: callout-note
# Objetivos de esta sección

1.  Obtener los centroides para cada una de las zonas censales (unidades geográficas).

2.  Crear las isócronas para cada zona censal con zonas de influencia de 0-10 min y de 10-20 min.
:::

## Cargar librerías y datos

```{r}

# Cargar Librerias
if (!require("pacman")) {
  install.packages("pacman")
  library(pacman)
} 

pacman::p_load(
  sf,           # Manipulación de datos espaciales
  tidyverse,    # Manipulación de datos 
  leaflet,      # Crear mapas interactivos
  profvis,
  hereR,        # Paquete para acceder a la API HERE 
  osmdata,
  sp
)

# Importar datos
ruta <- "../data/gpkg/base_map_dmq.gpkg"
mapa_base_dmq <- st_read(ruta,
                         layer = "dmq")

```

## Transformacion de los datos

```{r}

# Crear una poblacion aleatoria para cada zona censal
set.seed(123)

mapa_base_dmq <- mapa_base_dmq %>% 
  mutate(poblacion = sample(1000:10000, 
                            n(), 
                            replace = TRUE))

# Obtener los centroides de cada zona censal
centroides_dmq <- st_centroid(mapa_base_dmq) %>% 
  # Transformar de UTM a Geograficas 
  st_transform(4326)

# Visualizar los centroides
leaflet() %>% 
  # Añadir mapa base 
  addProviderTiles("CartoDB.Positron", 
                   group="Greyscale") %>% 
  
  # Añadir los centroides
  addCircleMarkers(data = centroides_dmq)
  
```

## Crear Isocronas

### Crear un solo conjunto de isocronas

```{r}

# Configurar la llave de HERE
# here_key <- ""
# set_key(here_key)

# Crear isocronas
iso <- isoline(
  # Punto(s) desde donde parte la isocrona. Debe ser un objeto sf
  poi = centroides_dmq[1,],
  
  # Vector que contiene los intervalos de corte en segundos (10 y 20 min) 
  range = c(10,20)*60,
  
  # Indica el tipo de rango: tiempo, distancia o energia 
  range_type = "time",
  
  # Fecha y tiempo del calculo para simular trafico en tiempo real 
  datetime = as.POSIXct(paste0(Sys.Date(), " 10:00"))
  
) %>%
  # Le asignamos una columna nueva para identificar cada nivel de las isocronas
  mutate(name = paste0((range - 600) / 60," to ", range / 60, " mins")) 

# Transformar el objeto sf a SpatialPolygonDataFrame para visualizarlo con leaflet
iso_vis <- as(iso, "Spatial")

# Visualizar las isocronas
leaflet() %>% 
  # Añadir mapa base 
  addProviderTiles("CartoDB.Positron", 
                   group="Greyscale") %>% 
  
  # Añadir las isocronas
  addPolygons(data = iso)

```

### Crear isocronas por cada centroide

```{r}

# Crear una carpeta para guardar los shapefiles de las isocronas
dir.create("../data/shp/isocronas/", 
           showWarnings = FALSE)

# Bluce para crear un conjunto de isocronas de 0-10 y 10-20 min por cada centroide
for(i in 1:nrow(centroides_dmq)){
  
  isocrona <- isoline(
    poi = centroides_dmq[i,],
    range = seq(10, 20, 10) * 60,
    range_type = "time",
    datetime <- as.POSIXct(paste0(Sys.Date()," 10:00"))
  ) %>%
    mutate(name = paste0((range - 600) / 60," to ", range / 60, " mins"))

  # Guardar poligonos en carpeta isocronas
  dsn <- paste0("../data/shp/isocronas/")
  
  # Asignar un nombre a cada archivo shapefile
  layer <- centroides_dmq$zon[i]
  
  st_write(obj = isocrona,
           dsn = dsn,
           layer = layer,
           driver = "ESRI Shapefile",
           append = TRUE)
 
  # Añadir una pausa de 1 segundo al crear los archivos para prevenir sobrecarga
  pause(1)
}
```

# Sección 2: Crear la matriz de influencia o captación

::: callout-note
## Objetivos de esta sección

1.  Trazar las ubicaciones de los proveedores sobre las zonas de influencia.
2.  Generar una matriz que identifice en qué subzona está localizada cada proveedor para cada zona censal.
:::

```{r}

# Ubicación de hosptiales en DMQ

hospitales_dmq <- getbb("Quito Ecuador") %>% 
  opq() %>% 
  add_osm_feature(key = "amenity",
                  value = "hospital") %>% 
  osmdata_sf()

str(hospitales_dmq)

hospitales_df <- hospitales_dmq$osm_polygons %>% 
  select(name, geometry) %>% 
  st_centroid() %>% 
  na.omit()

st_write(hospitales_df, "hospitales.shp")

# Colocar los hospitales sobre las areas de interes (isocronas)

shp_test <- st_read("data/shp/170150001.shp") #isocrona 

st_layers("data/shp/170150001.shp")

# Lista -------------------------------------------------------------------

isochrone_list <- "data/shp/"

shape.extension <- list.files(path = isochrone_list,
                              pattern = ".shp",
                              full.names = TRUE)

shape.names <- list.files(path = isochrone_list,
                          pattern = ".shp",
                          full.names = FALSE) %>%
  str_remove(".shp")

# Creamos la matriz 

matriz <- matrix(ncol = length(1),
                 nrow = nrow(hospitales_df))

colnames(matriz) <- shp_test
rownames(matriz) <- hospitales_df$name


head(matriz)

lista <- list()

for(i in 1:3){
  
  iso <- st_read(shape.extension[i])
  
  lista[[i]] <- st_join(hospitales_df,
                        iso[2,], 
                        join = st_within) %>% 
    select(name.x, name.y) %>% 
    rename_with(.cols = name.y, 
                .fn = ~paste0(.x, i)) %>% 
    as_tibble()
}

df <- reduce(lista, left_join)

funcion_join <- function(iso, indice){
  
  iso <- st_read(iso)
  
  st_join(hospitales_df,
          iso, 
          join = st_within) %>% 
    select(hospital = name.x, name.y) %>% 
    group_by(hospital, geometry) %>% 
    summarise(n = n_distinct(name.y),
              n2 = sum(is.na(name.y))) %>%
    mutate(n = n-n2) %>%
    select(-n2) %>% 
    rename_with(.cols = n,
                .fn = ~paste0("shape_", indice)) %>%
    as_tibble()
}

lista_2 <- map2(.x = shape.extension[1:10],
                .y = 1:10,
                funcion_join)

lista_3 <- map2(.x = shape.extension[1:3], 
                .y = 1:3, 
                funcion_join,
                fila = 2)

df_2 <- reduce(lista_2, left_join)
df_3 <- reduce(lista_3, left_join)

a <- st_join(hospitales_df,
             shp_test, 
             join = st_within) %>% 
  select(name.x, name.y)

str(hospitales_df)


for(i in 1:length(matriz)){
  matriz[,i] <- st_intersects(hospitales_df,
                                shp_test)$name
}

# Step 1: Check dimensions and types
print(dim(hospitales_df))
print(class(hospitales_df))
print(dim(shp_test))
print(class(shp_test))

st_crs(hospitales_df) == st_crs(shp_test)

length(hospitales_df) == length(shp_test)

```

# Crear la matriz de ponderaciones o pesos

# Medidas de la oferta y la demanda

# Calcular el Índice de acceso espacial
